import jax
import jax.numpy as jnp
import e3x

from functools import partial

import jaxpme
from jaxpme.utils import safe_norm


def get_predict_fn(apply_fn, stress=False, electrostatics="ewald",
                   lr_cutoff=None, excess_charge_neutralization=False,
                   pme_neutralization=False, electric_field=None):
    assert electrostatics in ["ewald", None], "PME is not yet supported"

    if electrostatics is not None:
        if electrostatics == "ewald":
            # units?
            coulomb_calc = jaxpme.Ewald(prefactor=jaxpme.prefactors.eV_A,
                                        exclusion_radius=lr_cutoff,
                                        full_neighbor_list=True,)
    if electric_field is None:
        electric_field = jnp.zeros((3,))
    else:
        # check that it is a 3-vector
        assert electric_field.shape == (3,), "Electric field must be a 3-vector"

    def energy_fn(params, batch):
        energies, q = apply_fn(
            params,
            batch.edges,
            batch.centers,
            batch.others,
            batch.nodes,
            batch.node_to_graph,
            batch.edge_mask,
            batch.node_mask,
        )
        energies *= batch.node_mask

        total_energy = jnp.sum(energies)

        return total_energy, (energies, q)

    energy_and_derivatives_fn = jax.value_and_grad(
        energy_fn, allow_int=True, has_aux=True, argnums=1
    )

    def predict(params, batch):
        batch_energy_and_atom_energies_and_atom_df, grads = (
            energy_and_derivatives_fn(params, batch)
            )
        _, (energies, q_i) = batch_energy_and_atom_energies_and_atom_df

        if  pme_neutralization:
            # Do the same for q_i
            q_i *= batch.node_mask
            excess_pme = q_i.sum()
            num_active_atoms = jnp.sum(batch.node_mask)
            q_i -= excess_pme / num_active_atoms

        energy = jax.ops.segment_sum(
            energies, batch.node_to_graph, batch.graph_mask.shape[0]
        )

        R_ij = batch.edges * batch.edge_mask[..., None]
        dR_ij = grads.edges * batch.edge_mask[..., None]

        forces_1 = jax.ops.segment_sum(
            dR_ij, batch.centers, batch.nodes.shape[0],
            indices_are_sorted=False
        )
        forces_2 = jax.ops.segment_sum(
            dR_ij, batch.others, batch.nodes.shape[0], indices_are_sorted=False
        )

        forces = forces_1 - forces_2

        if electrostatics is not None:
            # compute internal field generated by charges
            # check if the system is periodic
            if batch.full_edges is not None:
                # sc_coulomb(node_mask, positions, q_i, centers, others)
                U_int, grads = jax.value_and_grad(sc_coulomb, argnums=1)(
                    batch.node_mask, batch.full_edges, q_i, batch.full_centers,
                    batch.full_others,
                )
                dR_ij = grads * batch.full_edge_mask[..., None]
                forces_1 = jax.ops.segment_sum(
                    dR_ij, batch.full_centers, batch.nodes.shape[0],
                    indices_are_sorted=False
                )
                forces_2 = jax.ops.segment_sum(
                    dR_ij, batch.full_others, batch.nodes.shape[0],
                    indices_are_sorted=False
                )
                F_int = forces_1 - forces_2

            else:
                distances = safe_norm(batch.edges, axis=-1)
                U_int, F_int = coulomb_calc.energy_forces(
                    q_i,
                    batch.cell,
                    batch.positions,
                    batch.centers,
                    batch.others,
                    None,
                    batch.k_grid,
                    batch.smearing,
                    atom_mask=batch.node_mask,
                    pair_mask=batch.edge_mask,
                    distances=distances,
                )
        else:
            F_int = 0.0

        # With the current construction, we can use a fixed electric field
        # for the external field if we do MD

        # We distinguish the forces arising from the internal electrostatics,
        # and the interaction with the external field
        E_padded = jnp.zeros((batch.nodes.shape[0], 3))
        # set all vectors to the electric field, which we assume is vector 3
        E_padded = E_padded.at[batch.node_to_graph].set(
            electric_field
        )
        # Should we also add the Coulomb energy here?`
        energy += U_int

        results = {"energy": energy, "forces": forces}  # , "M": M}
        results["charges"] = q_i

        if stress:
            pre_stress = jnp.einsum("pa,pb->pab", R_ij, dR_ij)

            results["stress"] = (
                jax.ops.segment_sum(
                    pre_stress,
                    batch.edge_to_graph,
                    batch.graph_mask.shape[0],
                    indices_are_sorted=False,
                )
                * batch.graph_mask[..., None, None]
            )

        return results

    return predict


@partial(jax.jit, static_argnums=2)
def boolean_mask_1d(masked, mask, out_size, filler):
    # implements: masked[mask] = out in a jittable way.
    # result: out[0:mask.sum()] containing all entries
    # where mask == True, and the rest padded with filler
    # note that the last entry of out will always be filler

    # print("boolean_mask_1d")  # uncomment for jit testing
    out = jnp.ones(out_size, dtype=masked.dtype) * filler

    cumsum = jnp.cumsum(mask)
    locations = jnp.where(mask, cumsum - 1, out_size - 1)
    out = out.at[locations].set(jnp.where(mask, masked, filler))

    n_matches = cumsum[-1]
    overflow = n_matches + 1 > out_size

    return out, overflow


@partial(jax.jit, static_argnums=2)
def boolean_mask_Nd(masked, mask, out_shape, filler):
    # above, but for Nd arrays

    out_size = out_shape[0]
    extra_axes = [1] * (len(out_shape) - 1)

    out = jnp.ones(out_shape, dtype=masked.dtype) * filler

    cumsum = jnp.cumsum(mask)
    locations = jnp.where(
        mask, cumsum - 1, jnp.ones(mask.shape, dtype=int) * (out_size - 1)
    )
    out = out.at[locations].set(jnp.where(jnp.expand_dims(mask, extra_axes), masked, out))

    n_matches = cumsum[-1]
    overflow = n_matches + 1 > out_size

    return out, overflow


def sc_coulomb(node_mask, full_edges, q_i, centers, others):
    # full_edges = positions[others] - positions[centers]
    num_total_nodes = q_i.shape[0]  # Use static shape for JIT
    full_r_ij = e3x.ops.norm(full_edges, axis=-1)

    # Avoid division by zero for self-interactions
    mask = full_r_ij < 1e-6
    masked_r_ij = jnp.where(mask, 1.0, full_r_ij)  # Prevent NaNs in gradient
    one_over_r = jnp.where(mask, 0.0, 1 / masked_r_ij)

    # Calculate potentials on all nodes (active and inactive)
    potentials = jax.ops.segment_sum(
        q_i[others] * one_over_r,
        centers,
        num_segments=num_total_nodes,
        indices_are_sorted=False,
    )

    # factor 2 because of full neighbor list
    potentials *= jaxpme.prefactors.eV_A / 2

    # Calculate energy only for active nodes and sum
    energies = q_i * potentials * node_mask
    return jnp.sum(energies)
